syntax = "proto3";

package sse_protos;

service EncryptedSearch {
    rpc UploadMetaData(MetaData) returns (MetaDataAck);

    rpc UploadTSet(stream TSetFragment) returns (TSetAck);

    rpc UploadXSetFilter(XSetFilter) returns (FilterAck);

    rpc UploadCipherDocs(stream CipherDoc) returns (CipherDocAck);

    rpc KeywordSearch(KeywordQuery) returns (stream EncryptedDocInfo);

    rpc FetchDocuments(stream DocInfo) returns (stream CipherDoc);

    rpc ConjunctiveSearchRequest(stream BooleanSearchQuery) returns (stream CipherDoc);

    rpc XTokenExchange(stream XTokenRequest) returns (stream XTokenResponse);

}

service ProxySearch{
    rpc Search(PlainTextQuery) returns (stream PlainDoc);
}

message DocInfo {
    uint32 doc_id = 1;
}

message EncryptedDocInfo {
    bytes encrypted_id = 1;
}

message MetaData {
    int32 num_eid_bytes = 1;
    int32 num_blind_bytes = 2;
}

message MetaDataAck {
    bool ack = 1;
}

message TSetFragment {
    // stag = F(K_t, w)
    // b, L, K = F_p(stag, i)

    // e = xind (encrypted doc id)
    // y = xind * z_c^-1
    // s_i = (e || y) => 

    // (b || L) -> (B || s_i) XOR K
    bytes bucket = 1;
    bytes label = 2;
    bytes data = 3;
}

message XSetFilter {
    // filter of g^( F_p(K_x, w) * xind ) 
    bytes bloom_filter = 1;
}

message FilterAck {
    bool ack = 1;
}

message TSetAck {
    bool ack = 1;
}

message CipherDoc {
    // CipherDoc ID.
    uint32 doc_id = 1;
    bytes encrypted_doc = 2;
}

message PlainDoc {
    uint32 doc_id = 1;
    bytes doc_bytes = 2;
}

message CipherDocAck {
    bool ack = 1;
}

// stag = F(K_t, w)
message KeywordQuery {
    bytes stag = 1;
}

message PlainTextQuery {
    string query_word = 1;
}

message BooleanSearchQuery {
    enum SearchType {
        NEGATION = 0;
        SNF = 1;
        ARBITRARY = 2;
        DISJUNCTION = 3;
    }

    message NegatedConjunction {
       bytes stag = 1;
       string bool_query = 2;
    }

    message SearchableNormalForm {
        // stag ^ (xtag ^ ...)
        bytes stag = 1;
        string bool_query = 2;
    }

    message ArbitraryBoolQuery {
        // TRUE ^ (xtag AND xtag OR xtag)
        string bool_query = 1;
    }

    message DisjunctionQuery {
        string bool_query = 1;
    }

    SearchType type = 1;

    optional NegatedConjunction n_query = 2;
    optional SearchableNormalForm s_query = 3;
    optional ArbitraryBoolQuery a_query = 4;
    optional DisjunctionQuery d_query = 5;
}

message XTokenRequest {
    // TODO(roasbeef): add a search ID?
    bytes stag = 1;
    int32 doc_index = 2;
}

message XTokenResponse {
    bytes stag = 1;
    int32 doc_index = 2;
    bytes xtoken = 3;
}

message Error {
    // Error message for out of bounds caused by a word being too large for the FFX scheme
}
